{"name":"fibonacci-clojure","tagline":"clojure fibonacci memoization infinte-sequence recursive","body":"Clojure practice in small pieces : Fibonacci\r\n--------------------------------------------\r\n\r\nSo, you know some Clojure, and you want to practice a little bit, perhaps solving the [4clojure](http://www.4clojure.com/) problems. One such problem is computing the [Fibonacci numbers](http://en.wikipedia.org/wiki/Fibonacci_numbers).\r\n\r\nFor this session, I'll suggest to open a new file in your editor and to start the Clojure repl to follow along.\r\n\r\nThe (naive) recursive approach would produce code like this:\r\n```{clojure}\r\n(defn fibonacci-naive [n]\r\n  (if (<= n 1) n\r\n      (+ (fibonacci-naive (- n 1)) (fibonacci-naive (- n 2)))))\r\n```\r\nYou have a stop condition for the cases n=0, n=1, and you define f(n) as the sum of f(n-1) and f(n-2).\r\n\r\nYou can test the function:\r\n```{clojure}\r\n(map fibonacci-naive (range 10))\r\n```\r\n\r\nHowever, this solution does not work very well for a big n, where big depends on your machine. As you increase n, at one point you will observe that the computation starts to get slow. The reason is that you are doubling the number of computations with every recursive step.\r\nNote that, since the algorithm has two recursive calls, you can't perform a tail-call optimization. We'll come back to this.\r\n\r\nOne idea would be to store the intermediate computation in order to perform a computation only once. This technique is called memoization. We will use a map structure as a cache/lookup table. This particular approach will require mutation, so we'll use an atom for that.\r\n```{clojure}\r\n(atom {:0 0\r\n       :1 1})\r\n```\r\nThe cache is initially populated with the first 2 Fibonacci numbers. Next, we'll need a function to get a computed value for a given number from the cache.\r\n```{clojure}\r\n(fn [k]\r\n  ((keyword (str k)) @cache)))\r\n```\r\nWe'll also need a function to store a computed value in the cache (note the mutation).\r\n```{clojure}\r\n(fn [k v]\r\n  (swap! cache assoc (keyword (str k)) v))\r\n```\r\nWith these in place, we can now write a function that computes the value of a particular number and saves the value in the cache . This function assumes all the previous (technically the previous 2 are enough) numbers have been computed and are stored in the cache.\r\n```{clojure}\r\n(fn [i]\r\n  (let [result (+ (get-val (- i 1))\r\n                 (get-val (- i 2)))]\r\n   (do\r\n     (put-val i result)\r\n     result)))\r\n```\r\nget-val retrieves the value from the cache, put-value saves teh computed value to the cache.\r\nWe'll put all these together as bindings in a let expression. We will compute the first n numbers with a for expression.\r\n```{clojure}\r\n(defn fibonacci-with-state [n]\r\n  (let [cache (atom {:0 0\r\n                     :1 1})\r\n        get-val (fn [k]\r\n                  ((keyword (str k)) @cache))\r\n        put-val (fn [k v]\r\n                  (swap! cache assoc (keyword (str k)) v))\r\n        next (fn [i]\r\n               (let [result (+ (get-val (- i 1))\r\n                               (get-val (- i 2)))]\r\n                 (do\r\n                   (put-val i result)\r\n                   result)))]\r\n    (for [x (range 0 (inc n))]\r\n      (let [v (get-val x)]\r\n        (if (nil? v) (next x)\r\n            v)))))\r\n```\r\n\r\nYou can test safely this version on a big n number. It performs well, because any computation is done only once, and then is stored in memory in case it is needed.\r\nHaving arrived at this point, there is one important comment to make. Unlike the naive recursive version where we started the computation at the given n and descended towards 1 and 0, this memoized version (actually the for expression) starts from 0 and goes up toward the given n. Because of this, even a memoized version of fibonacci-naive won't perform, since the the needed compuations (the previous values) are not available in memory. You can try to see for yourself.\r\n```{clojure}\r\n((memoize fibonacci-naive) 10) ;; try increasing values for n\r\n```\r\n\r\nThe memoized solution is quite lengthy, it also uses mutations. Maybe there is a better way? Of course it is. I only took you on this detour to show you how to implement memoization in case you need it.\r\n\r\nWe have seen that the memoized version started from 0 and worked its way to the n. We will make a recursive version that will do the same, start from 0 and store the intermediary results. The trick is to use an accumulator as an argument that you will pass along each recursive step.\r\n```{clojure}\r\n(defn fibonacci-from-the-ground-up [n]\r\n  (letfn [(next-val [c]\r\n            (conj c (+ (last c) (last (butlast c)))))\r\n          (fibonacci-seq [c i]\r\n            (if (> i n) c\r\n                (fibonacci-seq (next-val c) (inc i))))]\r\n    (take n (fibonacci-seq [0 1] 2))))\r\n```\r\nWe have defined a helper function, next-val. This function takes the so-far computed Fibonacci numbers (a sequence), computes the next Fibonacci number (by using the last two elements of the input), and returns a new sequence where the computed number is conjoined to the input sequence.\r\nOur recursive function, fibonacci-seq takes now 2 arguments. The first argument is the solution (or the partial solution), the second argument is a number to used in the stopping condition. Once we have reached the desired number n, we simply return the accumulated solution.\r\n\r\nBefore going further, I'd like to take the time to make two comments about this solution. One, the recursive functions that employ the accumulator technique are amenable to tail-call optimizations. For that, the recursive call needs to be the last computation in the recursive step. I won't belabor the point further. And second, this technique is quite appreciated by programmers coming from imperative languages, but for the wrong reasons. To them this accumulation technique resambles mutation, and as a consequence of finding a familiar ground, they tend to overuse it.\r\n\r\nNext, let's get rid of the recursion. Being able to replace recursion with higher-order functions is key to writing more expressive programs. Now, if you'll think about it, we already are building the solution from the ground up. So we can use a reduce function that builds/accumulates the solution. The tricks to use, is to use a range for the numbers upto n, and to have as start value the sequence [0 1], same as the recursive solution.\r\n```{clojure}\r\n(defn fibonacci-reduce [n]\r\n  (let [next-val (fn [c _]\r\n                   (conj c (+ (last c) (last (butlast c)))))]\r\n    (take n (reduce next-val [0 1] (range 2 (inc n))))))\r\n```\r\n\r\nSo far, so good. Let's try writing the Fibonacci numbers as an infinte sequence. Instead of reduce we will use iterate. This function takes as arguments a function f, a starting value x and produces the infinite sequence x, f(x), f(f(x)), f(f(f(x))), ...\r\nSo let's transform the reduce version to an iterate version.\r\n```{clojure}\r\n(defn fibonacci-iterate [n]\r\n  (let [next-val (fn [c]\r\n                   (conj c (+ (last c) (last (butlast c)))))]\r\n    (last (take n (iterate next-val [0 1])))))\r\n```\r\n\r\nOK. Let me explain now how a lazy sequence works. What is needed is something that produces the next element of the sequence but at the same time it inhibits the evaluation of the rest of the sequence. How should a function that does precisely that, look like? A function should produce the next element and a lazy structure (for example an unevaluated function or a lazy sequence). Here is an example:\r\n```{clojure}\r\n(def fibonacci-generator\r\n  ((fn generator [a b] (lazy-seq (cons a (generator b (+ a b))))) 0 1))\r\n```\r\nNotice that the generator function does not accumulate the fibonacci numbers anymore. It only takes the last two values, needed to compute the next one. Notice also that fibonacci-generator is a function (generator).\r\nThis version of fibonacci is deceptively simple.\r\n```{clojure}\r\n(take 10 fibonacci-generator)\r\n```\r\n\r\nThe end of this post is already overdue, so as a reward for your patience I'll give you a version of fibonacci recursive sequence.\r\n```{clojure}\r\n(def fibs (concat [0 1] (map + fibs (rest fibs))))\r\n```\r\nThe function map returns a lazy sequence that is only realized on demand.\r\n\r\n```{clojure}\r\n(take 10 fibs)\r\n```\r\n\r\nSo, we have used the Fibonacci numbers as an excuse to explore some techniques of functional programming in general and of Clojure in particular: recursive functions, memoization and lazy inifinte sequences. Go forth and practice your newly acquired skills.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}